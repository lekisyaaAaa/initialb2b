esphome:
  name: knights
  friendly_name: Knights_IOT

esp32:
  board: esp32dev
  framework:
    type: arduino

# MQTT Configuration for VermiLinks backend
mqtt:
  broker: "mqtt://192.168.8.142:1883"  # Your Home Assistant IP
  username: "Knights_IOT"
  password: "smbcr-5540"
  client_id: knights_esp32
  discovery: false
  topic_prefix: vermilinks/knights
  birth_message:
    topic: vermilinks/knights/status
    payload: online
  will_message:
    topic: vermilinks/knights/status
    payload: offline
  on_message:
    topic: vermilinks/knights/command
    then:
      - lambda: |-
          ESP_LOGD("mqtt", "Received command: %s", x.c_str());
          // Parse command JSON and execute
          auto payload = x;
          if (payload.find("\"pump\":\"on\"") != std::string::npos) {
            id(vermilinks_esp32_water_pump).turn_on();
          } else if (payload.find("\"pump\":\"off\"") != std::string::npos) {
            id(vermilinks_esp32_water_pump).turn_off();
          } else if (payload.find("\"valve1\":\"pulse\"") != std::string::npos) {
            id(solenoid_valve_1_pulse).turn_on();
          } else if (payload.find("\"valve2\":\"pulse\"") != std::string::npos) {
            id(solenoid_valve_2_pulse).turn_on();
          } else if (payload.find("\"valve3\":\"pulse\"") != std::string::npos) {
            id(solenoid_valve_3_pulse).turn_on();
          }

wifi:
  ssid: "Knights_IOT"
  password: "smbcr-5540"
  fast_connect: true
  power_save_mode: none
  ap:
    ssid: "VermiLinks_Fallback"
    password: "12345678"

captive_portal:

api:
  password: "Bean2bin2025"

ota:
  platform: esphome
  password: "Bean2bin2025"

logger:
  level: DEBUG

# Globals (modes)
globals:
  - id: vermilinks_auto_mode_flag
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: vermilinks_manual_mode_flag
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: vermilinks_float_test_mode_flag
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: vermilinks_debug_mode_flag
    type: bool
    restore_value: yes
    initial_value: 'false'

# Sensors for MQTT publishing
sensor:
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_signal_sensor
    update_interval: 60s

  - platform: uptime
    name: "ESP32 Uptime"
    id: uptime_sensor
    update_interval: 60s

# Float sensor (GPIO14)
binary_sensor:
  - platform: gpio
    id: vermilinks_esp32_float_sensor
    name: "VermiLinks ESP32 Float Sensor"
    pin:
      number: 14
      mode: INPUT_PULLUP
    device_class: moisture
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      then:
        - lambda: |-
            if (id(vermilinks_auto_mode_flag) && !id(vermilinks_manual_mode_flag)) {
              id(vermilinks_esp32_water_pump).turn_off();
            }
            // Publish float sensor state change via MQTT
            id(mqtt_publish_float).publish_state("1");
    on_release:
      then:
        - lambda: |-
            if (id(vermilinks_auto_mode_flag) && !id(vermilinks_manual_mode_flag)) {
              id(vermilinks_esp32_water_pump).turn_on();
            }
            // Publish float sensor state change via MQTT
            id(mqtt_publish_float).publish_state("0");

# MQTT Publishers for sensor data
text_sensor:
  - platform: template
    id: mqtt_publish_float
    on_value:
      then:
        - mqtt.publish_json:
            topic: vermilinks/knights/data
            payload: |-
              root["deviceId"] = "knights";
              auto metrics = root.createNestedObject("metrics");
              metrics["floatSensor"] = x.c_str();
              metrics["waterLevel"] = x.c_str();
              auto metadata = root.createNestedObject("metadata");
              metadata["firmware"] = "esphome-v1.0";
              metadata["uptime"] = id(uptime_sensor).state;
              metadata["signal"] = id(wifi_signal_sensor).state;

# Relays (pump + solenoids)
switch:
  - platform: gpio
    id: vermilinks_esp32_water_pump
    name: "VermiLinks ESP32 Water Pump"
    pin: 18
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["pump"] = "on";
    on_turn_off:
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["pump"] = "off";

  - platform: gpio
    id: vermilinks_esp32_solenoid_valve_1
    name: "VermiLinks ESP32 Solenoid Valve 1"
    pin: 25
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["valve1"] = "on";
    on_turn_off:
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["valve1"] = "off";

  - platform: gpio
    id: vermilinks_esp32_solenoid_valve_2
    name: "VermiLinks ESP32 Solenoid Valve 2"
    pin: 26
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["valve2"] = "on";
    on_turn_off:
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["valve2"] = "off";

  - platform: gpio
    id: vermilinks_esp32_solenoid_valve_3
    name: "VermiLinks ESP32 Solenoid Valve 3"
    pin: 27
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["valve3"] = "on";
    on_turn_off:
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["valve3"] = "off";

  - platform: template
    name: "VermiLinks AUTO Mode"
    id: vermilinks_auto_mode
    optimistic: true
    turn_on_action:
      - lambda: 'id(vermilinks_auto_mode_flag) = true;'
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["mode"] = "auto";
    turn_off_action:
      - lambda: 'id(vermilinks_auto_mode_flag) = false;'
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["mode"] = "manual";
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "VermiLinks MANUAL Mode"
    id: vermilinks_manual_mode
    optimistic: true
    turn_on_action:
      - lambda: 'id(vermilinks_manual_mode_flag) = true;'
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["mode"] = "manual";
    turn_off_action:
      - lambda: 'id(vermilinks_manual_mode_flag) = false;'
      - mqtt.publish_json:
          topic: vermilinks/knights/status
          payload: |-
            root["deviceId"] = "knights";
            root["mode"] = "auto";
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "VermiLinks Float Test Mode"
    id: vermilinks_float_test_mode
    optimistic: true
    turn_on_action:
      - lambda: 'id(vermilinks_float_test_mode_flag) = true;'
    turn_off_action:
      - lambda: 'id(vermilinks_float_test_mode_flag) = false;'
    restore_mode: ALWAYS_OFF

  - platform: template
    name: "VermiLinks Debug Mode"
    id: vermilinks_debug_mode
    optimistic: true
    turn_on_action:
      - lambda: 'id(vermilinks_debug_mode_flag) = true;'
    turn_off_action:
      - lambda: 'id(vermilinks_debug_mode_flag) = false;'
    restore_mode: ALWAYS_OFF

# Pulse buttons for solenoids (momentary)
  - platform: template
    name: "Solenoid Valve 1 Pulse"
    id: solenoid_valve_1_pulse
    turn_on_action:
      - switch.turn_on: vermilinks_esp32_solenoid_valve_1
      - delay: 800ms
      - switch.turn_off: vermilinks_esp32_solenoid_valve_1

  - platform: template
    name: "Solenoid Valve 2 Pulse"
    id: solenoid_valve_2_pulse
    turn_on_action:
      - switch.turn_on: vermilinks_esp32_solenoid_valve_2
      - delay: 800ms
      - switch.turn_off: vermilinks_esp32_solenoid_valve_2

  - platform: template
    name: "Solenoid Valve 3 Pulse"
    id: solenoid_valve_3_pulse
    turn_on_action:
      - switch.turn_on: vermilinks_esp32_solenoid_valve_3
      - delay: 800ms
      - switch.turn_off: vermilinks_esp32_solenoid_valve_3

# Periodic telemetry publishing
interval:
  - interval: 5min
    then:
      - mqtt.publish_json:
          topic: vermilinks/knights/data
          payload: |-
            root["deviceId"] = "knights";
            auto metrics = root.createNestedObject("metrics");
            metrics["floatSensor"] = id(vermilinks_esp32_float_sensor).state;
            metrics["waterLevel"] = id(vermilinks_esp32_float_sensor).state;
            auto metadata = root.createNestedObject("metadata");
            metadata["firmware"] = "esphome-v1.0";
            metadata["uptime"] = id(uptime_sensor).state;
            metadata["signal"] = id(wifi_signal_sensor).state;

  - interval: 30s
    then:
      - lambda: |-
          bool float_present = id(vermilinks_esp32_float_sensor).state;
          if (id(vermilinks_auto_mode_flag) && !id(vermilinks_manual_mode_flag)) {
            if (!float_present) {
              id(vermilinks_esp32_water_pump).turn_on();
            } else {
              id(vermilinks_esp32_water_pump).turn_off();
            }
          }